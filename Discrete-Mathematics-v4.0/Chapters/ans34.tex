   \section*{Chapter 34}
   
   {\it There are usually many different recursive formulas that will be correct answers to the problems below.
   If your answer does not agree with the answer provided, you should use both formulas to generate a numbers of terms, say six or eight or so. If the numbers do not agree, your work is wrong. If they do agree, then likely your work is okay. You could make sure of that by using induction, for example, to show the two recursive formulas are equivalent.}
   
\begin{Solution}{34.1}  
Let $p_{n}$ be the number of pennies in the bank on day $n$. The initial value is $p_{0}= 0$.
The recursive relation is $p_{n}= p_{n-1} + n$, for $n\geq 1$.     
\end{Solution}


\begin{Solution}{34.2}

For $n\geq 0$, let $c_n$ be the number of different ways Sal can climb $n$ steps.

The initial conditions are $c_0 = 1$, and $c_1 = 1$. 

For the recursive formula: When climbing $n\geq 2$ steps, Sal can start with one step and finish the climb in $c_{n-1}$ ways, or start with two steps and finish the climb in $c_{n-2}$ ways. \\
 So, for $n\geq 2$, $c_n = c_{n-1}+c_{n-2}$.

\end{Solution}

\begin{Solution}{34.3}
Let $a_{n}$ be the number of bit strings of length $n$ with an even number of $0$'s. For an initial condition, we have $a_{1} =1$
since the only good length $1$ bit string is $1$. If the empty bit string doesn't bother you, we could use initial condition $a_{0} = 1$.
Now we think recursively: If we have a good bit string of length $n-1$, we can add a $1$ to the end to get a good bit string of length $n$.
That accounts for all the good length $n$ bit strings that end with $1$. We get the good bit strings of length $n$ that end with $0$by adding $0$
to the end of a {\it bad} length $n-1$ bit string. Using {\it good = total- bad} (well, actually {\it bad = total - good} in this case), we see there are $2^{n-1} -a_{n-1}$ bad bit strings. So, the solution is $a_{n} = a_{n-1} + (2^{n-1} - a_{n-1}) = 2^{n-1}$, for $n\geq 1$, with $a_{0}=1$
\end{Solution}

\begin{Solution}{34.4}

We can be sneaky about this and use the example in the text: A recursive relation for the number of bit strings
with no adjacent $0$'s is given by $a_0 =1$, $a_1 = 2$, and $a_n = a_{n-1}+a_{n-2}$ for $n\geq 2$. 
Let $b_n$ be the number of bit strings that do contain the pattern $00$, the ones we are really interested in. 
Now, using {\it good = total - bad}, $a_n = 2^n - b_n$.  So $b_0 = 0$ and $b_1 = 0$, and for $n\geq 2$ we get

\[
2^n - b_n = (2^{n-1} - b_{n-1}) + (2^{n-2} - b_{n-2})
\]
which can be rearranged as
\[
b_n = b_{n-1} + b_{n-2} + 2^n - 2^{n-1} - 2^{n-2} = b_{n-1} + b_{n-2} + 2^{n-2}.
\]

The sequence, for $n\geq 0$, begins: $0, 0, 1, 3, 8, 19, 43$, which agrees with a few brute force computations.

But that was sort of an unsportsmanlike solution since we didn't really reason recursively. So, let's try it again.
After getting $b_0 = 0$ and $b_1= 0$, let's think about how to build length $n\geq 2$ {\it good} bit strings. We could add $00$ to the right end of any of the $2^{n-2}$ bit strings of length $n-2$. Or, we could add $10$ 
to any of the $b_{n-2}$  good bit strings of length $n-2$. Or we could add $1$ to any of the $b_{n-1}$ good bit strings of length $n-1$. These three options account for all the good length $n$ bit strings,  the first two count the length $n$ bit string that end with $0$, and the last counts the good bit strings that end with $1$. So, the recursive part of the solution is, for $n\geq 2$,
\[
b_n = b_{n-1}+b_{n-2} + 2^{n-2}
\]
as before.

\end{Solution}

\begin{Solution}{34.5}

Again, there is an easy way to do this counting using the {\it good = total - bad} method. The only {\it bad} bit strings
have to look like a number of $1$'s followed on the right by a number of $0$'s. Examples: (length $n$)
$000\cdots0$, $100\cdots0$,$110\cdots0$,$111\cdots0$, and so on, until we get to $111\cdots1$. That is a total of $n+1$ {\it bad} strings. So the number of {\it good} length $n$ bit strings must be $2^n - (n+1)$.

The first few terms of the sequence, starting at $n = 0$, are : $0, 0, 1, 4, 11, 26, 57$.

But, again, that wasn't recursive counting. So let's try that again. Letting $g_n$ be the number of good strings of length $n$, we get $g_0 = 0$,  $g_1 = 0$, and $g_2 = 1$. That's enough for a start. Now let's think recursively.
For good strings of length $n\geq 1$, we can make good strings of length $n+1$ by adding a $0$ to the right end,
and that will account for all the good length $n+1$ strings ending with $0$. Next, let's count the number of good length $n+1$ strings ending with $1$. Here there are several choices depending on the number of $1$'s that end the bit string ({\it any} will mean any bit string of appropriate length):

\begin{itemize}
\item (any)01  ($2^{n-2}$ of these)
\item (any)011 ($2^{n-3}$ of these)
\item (any) 0111 ($2^{n-4}$ of these)
\item and so on until we reach $01111\cdots 1$ ($1$ of these)
\end{itemize}

So, we get

\[
g_n =  g_{n-1} + 2^{n-2} + 2^{n-3} + \cdots + 2 + 1 = g_{n-1} + \frac{2^{n-1}-1}{2-1} = g_{n-1} + 2^{n-1}-1.
\]

This doesn't look exactly like our first solution, so let's do a bit of testing. Checking this recursive formula  against the terms computed above, using initial value $g_{0} = 0$, we get

\[
0, 0, 1, 4, 11, 26, 57
\]
So things look pretty good.

\end{Solution}

\begin{Solution}{34.6}

Let $g_n$ be the number of ternary strings of length $n$ that contain $00$. A little trial{-}and{-}error 
gives the values $g_0 = 0$,
$g_1 = 0$, $g_2 = 1$, and $g_3 = 5$. For larger values of $n$ it is already too much trouble writing down the good strings without some sort of organized plan.

Let's break the problem of finding longer strings into a number of cases:
\begin{itemize}
\item Length $n$ strings ending with $1$. ($g_{n-1}$ of these)
\item Length $n$ strings ending with $2$. ($g_{n-1}$ of these)
\item Length $n$ strings ending with $0$.
  \subitem ending with $00$. ($3^{n-2}$ of these)
  \subitem ending with $10$. ($g_{n-2}$ of these)
  \subitem ending with $20$. ($g_{n-2}$ of these)
\end{itemize}

That accounts for all the good strings of length $n$, so the recursive formula is
\begin{gather*}
g_0 = 0 \qquad g_1 = 0\\
g_n = 2g_{n-1} +2g_{n-2} + 3^{n-2}.
\end{gather*}

The first few values are $0, 0, 1, 5, 21, 79, 281, 963, 3217$.

An alternative recursive answer (as given in sequence $A186244$ in the {\it The On-Line Encyclopedia of Integer Sequences}) (Google it!) is, 
\begin{gather*}
g_n = 3g_{n-1} + 2(3^{n-3} - g_{n-3}) \text{ for } n\geq 3\\
\text{ with } g_0 = 0 \qquad g_1 = 0 \qquad g_2 = 1
\end{gather*}

Reasoning: The recursive formula is based on adding any of $0,1,2$ to strings of length $n-1$ which already have $00$ in them, or $100,200$ to strings of length $n-3$ which do not.


\end{Solution}

\begin{Solution}{34.7}
Let $A_{n}= \{1,2,3,\ldots,n\}$.
A subset B of $A_{n}$ is good if $B$
 does not contain any two consecutive integers. 
Let $g_{n}$ be the number of good subsets of $A_{n}$.
Split the good subsets of $A_{n}$ into two groups:

(1) good subsets of $A_{n}$ that contain $n$

and

(2) good subsets of $A_{n}$ that do not contain n.\\[3pt]


Good subsets in group (1)  cannot contain $n-1$, and so those good 
subsets of $A_{n}$
 are produced by adding $n$ to a good subset of $A_{n-2}$
 (at least if $n\geq 2$). That accounts for all the good
 subsets of $A_{n}$ that contain $n$. 
That shows there are $g_{n-2}$ good subsets of $A_{n}$ that contain $n$.

Next, let's count the number of good subsets of $A_{n}$ that do not contain $n$.
But that is easy: these are just the good subsets of $A_{n-1}$, and so there are 
$g_{n-1}$ of these.

Conclusion: for $n\geq 2$, $g_{n}= g_{n-1} + g_{n-2}$ (the Fibonacci recurrence!).
We need initial terms: $g_{0}= 1$ and $g_{1}= 2$.

The first few values are $1, 2, 3, 5, 8, 13, 21, 34$. This is the Fibonacci
sequence with the first two terms discarded.

\end{Solution}


\begin{Solution}{34.8}

Maybe a bit surprisingly, this is a very difficult problem. A conjectured answer was given in $1941$, and evidently the conjecture was proved correct in $2014$.  No one has been able to solve the problem for more than four pegs,
though there are suspicions that remain unproven.

\end{Solution}

